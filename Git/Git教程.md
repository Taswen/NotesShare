# 一、Git安装

## windows下安装

Git官网 https://git-scm.com/ 下载安装Git，然后配置环境变量

在命令行中设定用户信息

```bash
git config --global user.name <name>	# 设定用户姓名
git config --global user.email <email>	# 设定用户邮箱
git config --list	# 列出git的信息
```

## Linux下安装

使用终端安装

```bash
apt-get install git
```



# 二、理解Git

Git是记录、控制版本的工具，它将版本文件和信息组织成树的形式。对于不同版本中的文件改动，Git会将其整个保存。

## Git的组织形式

Git为项目记录**当前工作区域**、**暂存区域**和**仓库区域**三部分信息，这三部分都是以树的形式组织文件。

### 当前工作区域（Working Directory）

即为项目文件夹，需要使用git的 `init` 指令指定和初始化

### 暂存区域（Stage）

临时存放工作区域的改动，事实上它只是一个文件，保存即将提交的文件列表信息。

### 仓库（Repository）

存放所有版本数据的地方。包含一个HEAD，一般情况下指向的是存入仓库的最新版本。



## Git的使用步骤

- 对项目文件夹用git的命令初始化
- 添加、修改或删除项目文件
- 使用git的命令将需要进行版本控制的文件添加到暂存区域
- 将暂存区域的文件提交到仓库形成新的版本



# 三、Git的具体使用

## 初始化或是克隆项目

### 初始化项目

进入项目文件夹的根目录（可以是新建的，也可以是已存在的），使用以下方式开始使用Git

```bash
git init 	# 提示 "Initialized empty Git repository in ......" 表示已经在当前目录下生成了仓库
```

>  初始化不会帮你把已经存在的文件自动生成第一版信息，需要后续手动操作

不带参数的`git init`会在目录中生成了 `.git` 这个子目录用作放置版本信息的仓库，所有有关项目的快照数据都将存放在这里。同时，该命令还会将目录作为工作区添加到版本库的监控中。

当然，也可以显示指定初始化的项目目录

```bash
git init <目录> # 目录是相对于当前所在路径
```



不带参数的`git init`将项目源码和仓库放在了一起。但有时需要将两者分开，这时候我们需要只

```bash
git init --bare
```





仓库与源码分离



### 克隆项目

有的时候并不是白手起家，而是克隆别人的项目

```bash
git clone <git链接> [指定路径名]
# 例如
git clone https://github.com/git-for-windows/git.git gitSource
```

指定路径名不是必须的，当不指定时，会在当前文件夹下新建一个与项目名同名的文件夹，并将克隆的项目文件放到这个新建的文件夹下。也可以是 `.`，意为直接克隆到当前目录下。也可以指定一个新文件夹名，git会帮你新建。

git能克隆远程仓库，也能克隆本地仓库，需要此时git链接就是本地仓库的目录。

```bash
# 例如
git clone d:/SourceRepository d:/DestinationRepository
```



## 提交文件和形成版本

### 添加文件/记录更改

要使文件受到git管控，需要两个条件：文件处于项目目录或是子目录下以及将已经它添加到暂存区或是已经提交过了。使用以下命令添加

```bash
 git add <文件>
 # 例如
 git add readme.txt
```

> 没有任何信息提示就是成功了

如果是第一次add新的文件，git会将文件纳入管控。add命令使git将提交的文件最新版添加到暂存区，此时文件处于待提交状态。

如果add的文件之间已经被提交过了，则git会记录文件的新变化（更改、删除、重命名），把它添加到暂存区。	

如果是删除了文件，同样也需要使用add命令添加修改到暂存区。







当没有添加新的文件而只是对已经提交了的文件做了更改，可以使用`-u`命令添加受跟踪文件的修改情况。

```bash
git add -u
```



当修改文件很多时，一个一个手动添加是低效的。可以使用`--all`或是`.` 来代表添加工作区所有改变

```bash
git add --all
# 或
git add .
```

> 两者的区别是
>
> `git add all `无论在哪个目录执行都会提交相应文件；
> `git add .` 只能提交当前目录或者子目录下相应文件；
>
> 另外
>
> - 1.x版本：
>
>     `git add all` 可以提交未跟踪、修改和删除文件。
>     `git add .` 可以提交未跟踪和修改文件，但不处理删除文件。
>
> - 2.x版本：
>
>     两者功能在提交类型方面是相同的，可以提交未跟踪、修改和删除文件。
>
> 





### 删除受跟踪的文件

使用rm可以删除已经受到管控的文件。使用方式如下：

```bash
git rm <文件>
```

> 注意，如果文件是未添加过的新文件，则会报找不到匹配文件的错误；也就说任何时候都不能把它用来删除不受git跟踪文件

相比于简单地从工作目录中手工删除文件，它还会自动更改文件的状态。具体来说有

- 之前提交过版本的但最新没有添加改动，直接删除文件并记录变化为删除。

- 删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 **-f**。它同样将文件删除，并更新暂存区文件状态为删除。

    ```bash
    git rm -f <文件>
    # 或者
    git rm --force <文件>
    ```

- 如果仅仅想把文件从暂存区域移除，仍然保留在当前工作目录中文件，则需要使用 **--cached** 选项。如果文件是初次添加，它会将文件变为未跟踪的状态；如果提交过版本，则会将文件在暂存区中直接标记为删除。上述都不会改变工作区中的文件。

    ```bash
    git rm --cached <文件>
    ```

    



### 提交版本

对需要修改的文件编辑后进行添加到暂存区，此时暂存区里都是应该提交的最新版的文件，为了将所有修改固定下了形成新的版本，需要使用commit命令

```bash
git commit -m <字符串注释>
```

每次提交都要填写注释，上述`-m`后跟的都是单行注释，如果没有空白符（空格，\r）可以不使用引号括起来

如果没有添加 `-m` ，则git会打开默认的编辑器让你编辑多行文本注释。

> commit 命令执行成功后，git会报告新版本对于旧版本的改动情况

提交只会将暂存区的文件提交上去，不会动未添加到暂存区的文件。



当只是更改了之前提交过的文件，适合使用 `-a` 参数

```bash
git commit –am '提交注释'
```



## 查看状态和改变

### 查看状态

对于工作区的文件有多种状态：没有受git管控的，受git管控更新过后但未添加到暂存区的，已经添加到暂存区但未提交的。

可以使用status命令查看仓库的当前状态

```bash
git status
```

> status命令会告诉你那些文件是“Untracked files”（未受跟踪），那些文件是“Changes not staged for commit”（修改了未添加），那些文件是"Changes to be commited"（添加了待提交）。对于添加了待提交的，git会标明那些是“modifed”，那些是""，那些是"deleted"。这里比较特殊的是被删除的已经被跟踪的文件也需要先add，才可以提交状态更改。



### 查看修改

#### 工作区与暂存区比

对于某个单文件，想要知道具体修改了什么，需要使用diif命令

```bash
git diff <文件名>
# 例如
git diff readme.txt
```

> 结果显示的格式正是Unix通用的diff格式

只有受到监控的文件才能使用diff命令查看修改。默认情况下，diff命令查看的是工作区和暂存区文件的区别，要是暂存区没有文件，才会比较工作区与上一个版本文件的区别。

如果有文件移动情况，可以加上`-M `参数，尝试让git检测文件移动。



> 对于diff命令只适用于文本文件，而对于图片视频等二进制文件git不能辨别修改，只能管理是否添加或是删除。



#### 暂存区与上一个版本比

要想知道暂存区与上一个版本文件的区别，需要添加cached参数。

```bash
git diff --cached <文件名>
# 例如
git diff --cached readme.txt
```

> ```bash
> git diff --staged <文件名>
> ```
>
> 是
>
> ```bash
> git diff --cached <文件名>
> ```
>
> 的同义词，两者功能一样



#### 工作区与上一个版本比

想直接查看工作区文件和上一个版本文件的区别，需要使用HEAD参数

```bash
git diff HEAD -- <文件名>
# 例如
git diff HEAD -- readme.txt
```





### 查看历史版本

想要过去版本都是什么样的，可以使用log命令

```bash
git log
```

> 显示从最近到最远的所有提交以及操作日志，包含了每次提交后的版本编码、提交日期、作者和注释

当版本多的时候，输出将会很多，不利于我们查找信息。使用参数pretty=oneline可以缩每个版本信息到一行

```bash
git log --pretty=oneline
```

> 此时每个版本信息只有一行，只显示每个版本的编码和注释，



## 版本回退、回退恢复与撤销修改

### 回退

有时候出现了错误，想要返回某个版本。可以使用reset命令

```bash
git reset --hard <版本编号>
```

> 版本编号可以不用写全，只要能够标示唯一的某个版本就行。成功后git会报告修改后的当前版本编号。

这里HEAD标示当前的版本，想要回退上一个版本可以使用 HEAD\^ 参数来表示当前版本的上一个版本。

```bash
git reset --hard HEAD^
```

那么上上一个版本就是 HEAD\^\^，以此类推。当想要回到几十个版本之前显然写很多\^是极为不方便的。可以使用HEAD\~参数

```bash
git reset --hard HEAD~<非零整数>
```

> 版本将会回退到几个之前版本之前，





上述带hard参数的版本回退会自动恢复工作区所有受到监管的文件的状态到指定版本，而原来没有add或是add了还没有comit的都会被擦掉（且不可恢复！），也就是此时以指定的原来版本为准，工作区、暂存区的状态与之对其一致。当然没有受监管的文件则不会被git改变。

如果想要只重置版本库的状态而不想改动暂存区和工作区的文件，使用soft参数

```bash
git reset --soft <版本编号>
```

> 仓库版本会回退到指定版本。成功后没有提示。而原来的工作区和暂存区的文件没有改变。此时如果使用status可以看出暂存区和最后的版本存在差异。



如果想要将版本和暂存区的文件回退，保留工作区现有的状态，使用mixed参数或是不带参数。

```bash
git reset --mixed <版本编号>
# 或是
git reset <版本号>
```

这也可以用来移除错添加到暂存区了的文件，

```bash
git reset HEAD <文件名>
```

> 这个只在仓库里至少有一版本时才有效，否则会报告不存在HEAD错误



使用rm命令加cached参数可以移除错添加到暂存区的文件，这个没有限制

```bash
git rm --cached <文件名>
```



### 回退恢复

当回退到原来版本时发现是操作失误，只要还记得回退前的版本的编号还可以恢复回去的。而当不知道时，也可以使用reflog命令查看版本的指向更改情况来查询曾经的版本。

```bash
git reflog
```

> 将会显示每次提交或是改变HEAD指向的引用变更信息。



需要注意的是，使用reset进行版本回退实质上是改变了标示当前版本的HEAD的指向，而没有删除版本的内容，从原来版本到回退之后的版本之间的那些版本并没有被丢弃而是被隐藏了，版本历史上也不会记载他们。使用reflog命令才能查看过往这些版本的编号。

当推送到远程时时，那些被隐藏的版本不会被同步，而当.git/log丢失时这些被删除的版本将不再能被找到。



### 版本撤销

如果不是全都是错误，只是想要撤销掉某些版本的修改，需要使用revert命令

```bash
git revert <版本编号1>..<版本编号n>
```

> git将撤销掉版本编号1和版本编号n之间的内容（包含版本编号1但不包含版本编号n），对每个撤销的 commit 都进行一次提交操作，

想要最后一起手动提交，可以使用no-commit参数

```bash
git revert --no-commit <版本编号1>..<版本编号n>
git commit -a -m "撤销了版本编号1到版本编号n之间的内容"
```





### 放弃修改

当对工作区的修改不满意想要放弃修改时，可以使用checkout命令将暂存区中(如果没有再到版本库中)的文件检出以覆写修改的文件。

```bash
git checkout -- <文件名>
# 例如
git checkout -- readme.txt
```

这里有两种情况：

一种是文件修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

一种是文件修改后已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

需要注意的是命令中的 `--` 不能省略，否则就变成切换分支的意思了，新版的git为了防止误操作新添加了一个指令restore，可以用以下命令达到从版本库恢复到暂存区（相当于撤销了add）的效果。

```
git restore --staged <文件名>
```

使用worktree参数可以从暂存区恢复到工作区（相当于在工作区撤销了修改）

```bash
git restre --worktree <文件名>
```





## 远程仓库同步

### 从远程库克隆到本地

使用clone命令可以从远程库下载到本地，在开始新建库中已有介绍。

需要注意的是git支持多种协议，SSH是一种，也可以使用https协议。https协议克隆到本地不需要口令，但是在推送的时候就需要了。

https很慢。



#### 通过SSH传输

本地Git仓库和远程仓库之间的传输是通过SSH加密，所以需要设置SSH key

在用户目录下如果没有.ssh目录则需要新建一个，在.ssh目录下没有id_rsa和id_rsa.pub两个文件则需要创建SSH Key。在本地的git仓库目录下执行以下命令

```bash
ssh-keygen -t rsa -C <邮箱字符串>
```

> 执行成功后会显示存放key的目录，在该目录下生成了一对密匙：id_rsa和id_rsa.pub

然后就可以将公匙分发给远端也就是git服务器了。

> 如果选择github作为服务器，则需要打开“Account settings”，“SSH Keys”页面，点击“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。





### 添加远程库

有时想要将本地项目关联到远程项目以实现同步，则需要使用以下命令进行设置

```bash
git remote add origin <远程库地址>
```

> 远程库的名字用`origin`表示，这是Git默认的叫法，也可以改成别的







### 更换远程库

```bash
git remote origin set-url <url>
```



### 查看远程关联库

```bash
git remote -v
```







### 推送本地到远程库

使用push命令可以将本地库的内容推送到远程库

```bash
git push -u origin master
```

> master 代表本地的主分支，

`-u`参数需要在第一次推送的时候加上，这样Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。

以后推送就可以使用

```bash
git push origin master
```



如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名





第一次连接GitHub时，会验证GitHub服务器的Key，同时发出警告，需要我们手动确认GitHub的Key的密匙信息，当键入yes，Git会输出一个警告，告诉已把GitHub的Key添加到本地的信任列表里了，以后就可以进行通信了。



如果需要推送所有分支则加上 `--all` 参数，如下

```bash
git push --all origin
```







### 拉取远程库代码

#### 直接拉取并更新工作区

当完成远程关联后可以从远程库拉取最新的代码了。

使用`pull`拉取远程最新代码并自动merge到本地，并更新到分支的本地仓库区和本地工作区（这就说明在`pull`之前需要将代码commit，不然`pull`会把本地未提交的修改覆盖）。

```bash
git pull <远程主机名> <远程分支名>:<本地分支名>
```

> 其中本地分支与远程分支相同名的话则可写作一个。

`pull`会直接拉取并merge，当有冲突时才需手动解决。

> 实际上，`pull`做了以下工作：先拉取远程服务器上的分支到本地上对应的远程分支(origin/分支)，再尝试merge到对应的本地分支。如果本地分支落后于远程的分支，则直接重置本地分支指针到远程分支(origin/分支)的位置，然后重置`HEAD`指针到最新；如果本地分支已经有延伸，则需要手动merge出一个新版本。

#### 拉取前审查再合并

有时我们需要在merge前了解远程最新代码的情况。则使用`fetch`更为稳妥。

```bash
git fetch <远程主机名> <远程分支名>:<本地分支名>
```

> 与`pull`一样，本地分支与远程分支相同名的话则可写作一个。

它会先从远程仓库的分支下载代码到本地的存储远程的分支（比如远程master分支下载到本地remotes/origin/master）。需要我们手动merge，在此之前可以使用以下命令比较区别

```bash
git log -p master.. origin/master
```

然后手动merge

```bash
git merge origin/master
```

上述操作每次只能操作一个分支，想要所有分支一起则使用`--all`参数

```bash
git fetch --all
git pull --all
```



#### 强制拉取覆写本地

放弃自己本地分支的所有修改，以远程库分支为准，则需要使用`fetch`后，直接`reset --hard origin/分支` ，这样会抛弃未提交的所有更改以及与远程库分支所有分歧，把本地分支的当前指针指向远程分支(origin/分支)。









## 模块化

当项目越来越庞大之后，希望将其拆分成多个子模块，各个子模块有独立的版本管理，就要用到git的submodule功能。

### 添加子模块

在工作区内想要放置子模块的地方，使用如下命令为一个已存在的 Git 仓库添加远程的子模块。

```python
git submodule add <仓库地址>
```

默认情况下，git会clone子模块项目并将其放到一个与子仓库同名的目录中。 如果想要放到其他地方，可以在命令结尾添加一个不同的路径。

命令运行后，git 添加一个`.gitmodules` 配置文件(如果有的话就更改)来说明项目的子模块使用情况，并会将`.gitmodules` 配置文件和 clone下来的子模块项目自动 `add` 。

> `.gitmodules` 配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：
>
> ```ini
> [submodule "DbConnector"]
> 	path = DbConnector
> 	url = https://github.com/chaconinc/DbConnector
> ```



#### 更新子模块









## 配置管理

git在通过配置文件存储配置。配置分为**系统配置**、**全局配置**和**仓库配置**

- `/etc/gitconfig` 文件:
    包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）

    > Windows系统下对应Git安装目录下`/etc/gitconfig`
    >
    > 如果安装的不是便携版本的，则应该还有一处存放了系统级的配置文件`C:\ProgramData\Git\config`

- `~/.gitconfig` 或 `~/.config/git/config` 文件:
    只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上 **所有** 的仓库生效。

> Windows系统下对应用户目录，`$HOMEPATH/.gitconfig`

- 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config`）:
    针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）

每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 和`~/.gitconfig`中的配置变量。

可以通过以下命令查看所有的配置以及它们所在的文件：

```bash
git config --list --show-origin
```

除了通过更改配置文件来设置或是更改配置，git提供了`config`命令来操作这三种配置。

### 查看配置情况

使用`--list`加范围`--system`/`--global`/`--local`来指定想要查看的配置。不加范围默认情况下使用的是`--global`

> 不只是查看，所以操作都可以使用范围参数来指定操作的范围

### 修改配置

使用以下的形式来修改配置

```bash
git config <配置名> <配置值>
```

如

```bash
git config user.name Hello
```

同样，不加范围默认情况下使用的是`--global`







## 分支管理

每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。创建仓库时，git会默认建立一个主分支，及master。前面说的HEAD指向就是master，而master指向的才是最后的版本。每次提交，master 分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。

对于所有分支而言， 工作区和暂存区是公共的。



### 查看分支

查看所有本地仓库的分支

```bash
git branch
```

查看关联的远程的分支

```bash
git branch -r
```

查看所有分支，包括本地的和关联的远程的

```bash
git branch -a
```







### 建立分支

使用checkout命令加参数-b创建一个新的分支

```bash
git checkout -b <分支名>
# 例如
git checkout -b newB
```

> git会做以下工作：新建了一个指针叫newB，并把它指向master指向的版本，而再把HEAD指向newB。以后提交和修改默认就是针对这个新分支了，新分支指针会随着提交前移，而mastr会停在原地。



### 推送分支

如果是在本地建立的新分支









### 切换分支

使用checkout命令来切换分支

```bash
git checkout <分支名>
# 例如
git checkout master
```

> 输出会提示切换到了分支，此时git会将HEAD指向master。

切换分支时会把要切换的分支的内容检出覆写工作区和暂存区内容。

如果切换时工作区相对于版本库的内容有修改而没有添加到暂存区或是添加到暂存区但没有提交，而切换分支后版本库里这文件的内容不一样了，就会报告错误，因为存在数据被覆写后丢失的风险，需要将更改提交形成版本后才能切换分支。

如果当前工作区、暂存区和版本一致（无改动），、s'x'C



新版的git为了防止误用checkout指令，同样提供了一个新的指令switch来切换分支

```bash
git switch -c <分支名>
```

> 使用c参数意为创建新的分支，并切换到这个新的分支



直接切换到已有的

```bash
git switch <分支名>
```





### 分支合并

使用merge命令可以将分支合并到当前分支上

```bash
git merge <分支名>
```

> 根据各分支情况不同，git将会采取不同的模式，如果两个分支不打架，合并的实质只是将先进的分支合并到落后的分支时就是Fast-forward，这种情况下一需要改变指针指向就行，所以速度很快



当两个分支都有了各自的提交内容，并且这些内容可能会发生冲突时，合并就会报告CONFLICT错误，此时使用status命令也可以看到冲突的文件有哪些





git







### 删除分支

使用branch命令加d参数就可以删除分支

```bash
git branch -d <分支名>
```

> 删除分支实质是删除了其分支指针。









